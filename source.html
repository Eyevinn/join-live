<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBS Browser Source - Live Stream</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        .video-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: #000000;
        }
        
        .stream-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #000000;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        .video-container.side-by-side {
            display: flex;
            flex-direction: row;
            align-items: stretch;
        }
        
        .video-container.side-by-side .stream-video {
            width: 50%;
            height: 100%;
            position: relative;
            display: block !important;
            flex: 1;
        }
        
        .video-container.side-by-side .stream-video:first-child {
            border-right: 1px solid #333;
        }
        
        #streamVideo2 {
            display: none;
        }
        
        .video-container.side-by-side #streamVideo2 {
            display: block !important;
        }
        
        .video-divider {
            width: 2px;
            background: #333;
            flex-shrink: 0;
        }
        
        .overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            display: none;
        }
        
        .status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            font-size: 16px;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error {
            color: #ff6b6b;
        }
        
        .waiting {
            color: #74c0fc;
        }
        
        .unmute-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
        }
        
        .unmute-btn {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border: 2px solid #fff;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .unmute-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
        }

        .qr-code-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            display: none;
        }

        .qr-code-wrapper {
            background: white;
            padding: 20px;
            border-radius: 15px;
            display: inline-block;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(255, 255, 255, 0.2);
        }

        .qr-header h1 {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 10px;
            color: white;
        }

        .qr-header p {
            font-size: 24px;
            color: #ccc;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="videoContainer" class="video-container">
        <video id="streamVideo" class="stream-video" autoplay playsinline muted></video>
        <video id="streamVideo2" class="stream-video" autoplay playsinline muted></video>
        <div id="overlay" class="overlay"></div>
        <div id="unmutePrompt" class="unmute-prompt" style="display: none;">
            <button id="unmuteBtn" class="unmute-btn">ðŸ”Š Click to Enable Audio</button>
        </div>
        <div id="status" class="status waiting">
        </div>
        <div id="qrCodeContainer" class="qr-code-container">
            <div class="qr-header">
                <h1>Join Live Stream</h1>
                <p>Scan QR Code to Participate</p>
            </div>
            <div class="qr-code-wrapper">
                <img id="qrImage" width="300" height="300" alt="QR Code for joining live stream">
            </div>
        </div>
    </div>
    
    <script src="config.js"></script>
    <script type="module">
        class OBSBrowserSource {
            constructor() {
                this.currentPlayer = null;
                this.currentPlayer2 = null;
                this.currentChannelId = null;
                this.currentChannelIds = [];
                this.videoContainer = document.getElementById('videoContainer');
                this.videoElement = document.getElementById('streamVideo');
                this.videoElement2 = document.getElementById('streamVideo2');
                this.overlay = document.getElementById('overlay');
                this.status = document.getElementById('status');
                this.unmutePrompt = document.getElementById('unmutePrompt');
                this.unmuteBtn = document.getElementById('unmuteBtn');
                this.qrCodeContainer = document.getElementById('qrCodeContainer');
                this.qrImage = document.getElementById('qrImage');
                this.isAudioEnabled = false;

                this.loadConfiguration();
                this.initializeWebSocket();
                this.initializeAudioControl();
                this.initializeQRCode();
            }
            
            loadConfiguration() {
                this.whepGatewayUrl = window.WHEP_GATEWAY_URL || window.WHIP_GATEWAY_URL || 'https://eyevinnlab-livevibe.eyevinn-wrtc-egress.auto.prod.osaas.io';
                this.whepAuthKey = window.WHEP_AUTH_KEY || window.WHIP_AUTH_KEY || null;
                
                console.log('OBS Source - WHEP Gateway:', this.whepGatewayUrl);
            }
            
            initializeWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}`;
                
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    console.log('WebSocket connected');
                };
                
                this.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        switch (data.type) {
                            case 'channelSelected':
                                if (data.channelId && data.channelId !== this.currentChannelId) {
                                    this.switchToStream(data.channelId);
                                }
                                break;
                                
                            case 'multipleChannelsSelected':
                                if (data.channelIds && data.channelIds.length > 0) {
                                    this.switchToMultipleStreams(data.channelIds);
                                }
                                break;
                                
                            case 'channelDeselected':
                                this.clearStream();
                                break;
                        }
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error);
                    }
                };
                
                this.ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    // Attempt to reconnect after 3 seconds
                    setTimeout(() => {
                        this.initializeWebSocket();
                    }, 3000);
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
            }
            
            async switchToMultipleStreams(channelIds) {
                console.log(`Switching to multiple streams: ${channelIds.join(', ')}`);

                // If only one channel, use single stream mode
                if (channelIds.length === 1) {
                    return this.switchToStream(channelIds[0]);
                }

                // Hide QR code when switching to streams
                this.hideQRCode();

                // Clean up existing players
                if (this.currentPlayer) {
                    this.currentPlayer.destroy();
                    this.currentPlayer = null;
                }
                if (this.currentPlayer2) {
                    this.currentPlayer2.destroy();
                    this.currentPlayer2 = null;
                }

                // Clear single stream state
                this.currentChannelId = null;
                this.currentChannelIds = channelIds;

                // Switch to side-by-side layout only for 2+ streams
                this.videoContainer.classList.add('side-by-side');
                
                console.log('Side-by-side layout applied:', {
                    containerClass: this.videoContainer.className,
                    hasMultipleChannels: channelIds.length
                });

                this.updateOverlay(`${channelIds.length} participants`);
                this.showStatus('loading', 'Loading streams...');

                try {
                    // Load first stream
                    if (channelIds[0]) {
                        await this.loadStreamToVideo(channelIds[0], this.videoElement, 'currentPlayer');
                    }
                    
                    // Load second stream if available
                    if (channelIds[1]) {
                        await this.loadStreamToVideo(channelIds[1], this.videoElement2, 'currentPlayer2');
                    }
                } catch (error) {
                    console.error('Failed to load multiple streams:', error);
                    this.showStatus('error', `Failed to load streams: ${error.message}`);
                }
            }
            
            async switchToStream(channelId) {
                console.log(`Switching to stream: ${channelId}`);

                // Hide QR code when switching to stream
                this.hideQRCode();

                // Clean up existing players
                if (this.currentPlayer) {
                    this.currentPlayer.destroy();
                    this.currentPlayer = null;
                }
                if (this.currentPlayer2) {
                    this.currentPlayer2.destroy();
                    this.currentPlayer2 = null;
                }

                // Reset to single stream layout
                this.videoContainer.classList.remove('side-by-side');
                this.currentChannelIds = [];

                this.currentChannelId = channelId;
                this.updateOverlay(channelId);
                this.showStatus('loading', 'Loading stream...');

                try {
                    await this.loadStream(channelId);
                } catch (error) {
                    console.error('Failed to load stream:', error);
                    this.showStatus('error', `Failed to load stream: ${error.message}`);
                }
            }
            
            async loadStream(channelId) {
                // First, get the stream info from the WHEP channel endpoint
                const streamInfo = await this.getStreamInfo(channelId);
                
                if (!streamInfo) {
                    throw new Error('Stream not found');
                }
                
                // Construct WHEP playback URL
                let whepPlaybackUrl;
                if (streamInfo.resource) {
                    whepPlaybackUrl = `${this.whepGatewayUrl}${streamInfo.resource}`;
                } else {
                    whepPlaybackUrl = `${this.whepGatewayUrl}/whep/${channelId}`;
                }
                
                console.log(`Loading stream from: ${whepPlaybackUrl}`);
                
                // Load WebRTCPlayer from CDN
                if (!window.WebRTCPlayer) {
                    await this.loadWebRTCPlayer();
                }
                
                // Create new player
                this.currentPlayer = new window.WebRTCPlayer({
                    video: this.videoElement,
                    type: 'whep'
                });
                
                // Handle player events
                this.currentPlayer.on('connecting', () => {
                    console.log('Stream connecting...');
                    this.showStatus('loading', 'Connecting to stream...');
                });
                
                this.currentPlayer.on('connected', () => {
                    console.log('Stream connected');
                    this.hideStatus();
                    this.overlay.style.display = 'block';
                });
                
                this.currentPlayer.on('error', (error) => {
                    console.error('Stream error:', error);
                    this.showStatus('error', 'Stream error');
                });
                
                this.currentPlayer.on('disconnected', () => {
                    console.log('Stream disconnected');
                    this.showStatus('error', 'Stream disconnected');
                });
                
                // Also listen to video element events as fallback
                this.videoElement.addEventListener('canplay', () => {
                    console.log('Video can play');
                    this.hideStatus();
                    this.overlay.style.display = 'block';
                });
                
                this.videoElement.addEventListener('playing', () => {
                    console.log('Video playing');
                    this.hideStatus();
                    this.overlay.style.display = 'block';
                });
                
                this.videoElement.addEventListener('error', (error) => {
                    console.error('Video error:', error);
                    this.showStatus('error', 'Video error');
                });
                
                // Start playback
                await this.currentPlayer.load(new URL(whepPlaybackUrl));
            }
            
            async loadStreamToVideo(channelId, videoElement, playerProperty) {
                console.log(`Starting to load stream ${channelId} to ${playerProperty}`, {
                    videoElementId: videoElement.id,
                    videoElementDisplay: window.getComputedStyle(videoElement).display
                });
                
                // First, get the stream info from the WHEP channel endpoint
                const streamInfo = await this.getStreamInfo(channelId);
                
                if (!streamInfo) {
                    throw new Error(`Stream ${channelId} not found`);
                }
                
                // Construct WHEP playback URL
                let whepPlaybackUrl;
                if (streamInfo.resource) {
                    whepPlaybackUrl = `${this.whepGatewayUrl}${streamInfo.resource}`;
                } else {
                    whepPlaybackUrl = `${this.whepGatewayUrl}/whep/${channelId}`;
                }
                
                console.log(`Loading stream ${channelId} from: ${whepPlaybackUrl} to ${playerProperty}`);
                
                // Load WebRTCPlayer from CDN
                if (!window.WebRTCPlayer) {
                    await this.loadWebRTCPlayer();
                }
                
                // Create new player
                const player = new window.WebRTCPlayer({
                    video: videoElement,
                    type: 'whep'
                });
                
                // Store player reference
                this[playerProperty] = player;
                
                // Handle player events
                player.on('connecting', () => {
                    console.log(`Stream ${channelId}: Connecting...`);
                });
                
                player.on('connected', () => {
                    console.log(`Stream ${channelId}: Connected`);
                    this.hideStatus();
                    this.overlay.style.display = 'block';
                });
                
                player.on('error', (error) => {
                    console.error(`Stream ${channelId}: Error:`, error);
                    this.showStatus('error', `Stream ${channelId} error`);
                });
                
                player.on('disconnected', () => {
                    console.log(`Stream ${channelId}: Disconnected`);
                    this.showStatus('error', `Stream ${channelId} disconnected`);
                });
                
                // Also listen to video element events as fallback
                videoElement.addEventListener('canplay', () => {
                    console.log(`Video ${channelId} can play`);
                    this.hideStatus();
                    this.overlay.style.display = 'block';
                });
                
                videoElement.addEventListener('playing', () => {
                    console.log(`Video ${channelId} playing`);
                    this.hideStatus();
                    this.overlay.style.display = 'block';
                });
                
                videoElement.addEventListener('error', (error) => {
                    console.error(`Video ${channelId} error:`, error);
                    this.showStatus('error', `Video ${channelId} error`);
                });
                
                // Start playback
                await player.load(new URL(whepPlaybackUrl));
            }
            
            async getStreamInfo(channelId) {
                const whepChannelEndpoint = this.whepGatewayUrl + '/whep/channel';
                
                const headers = {};
                if (this.whepAuthKey) {
                    headers['Authorization'] = `Bearer ${this.whepAuthKey}`;
                }
                
                try {
                    const response = await fetch(whepChannelEndpoint, {
                        method: 'GET',
                        headers: headers
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    
                    // Handle different response formats and find the specific channel
                    let streams = [];
                    if (Array.isArray(data)) {
                        streams = data;
                    } else if (data.streams && Array.isArray(data.streams)) {
                        streams = data.streams;
                    } else if (data.channels && Array.isArray(data.channels)) {
                        streams = data.channels;
                    }
                    
                    // Find the stream with matching channelId
                    return streams.find(stream => 
                        (stream.channelId || stream.id || stream.streamId || stream.channel) === channelId
                    );
                    
                } catch (error) {
                    console.error('Failed to get stream info:', error);
                    return null;
                }
            }
            
            async loadWebRTCPlayer() {
                const cdnUrls = [
                    'https://cdn.skypack.dev/@eyevinn/webrtc-player',
                    'https://unpkg.com/@eyevinn/webrtc-player/dist/main.js?module'
                ];
                
                for (const url of cdnUrls) {
                    try {
                        console.log(`Loading WebRTCPlayer from: ${url}`);
                        const module = await import(url);
                        const WebRTCPlayer = module.WebRTCPlayer || module.default?.WebRTCPlayer;
                        
                        if (WebRTCPlayer) {
                            window.WebRTCPlayer = WebRTCPlayer;
                            console.log('WebRTCPlayer loaded successfully');
                            return;
                        }
                    } catch (error) {
                        console.warn(`Failed to load from ${url}:`, error);
                    }
                }
                
                throw new Error('Failed to load WebRTCPlayer from CDN');
            }
            
            clearStream() {
                console.log('Clearing stream(s)');

                if (this.currentPlayer) {
                    this.currentPlayer.destroy();
                    this.currentPlayer = null;
                }
                
                if (this.currentPlayer2) {
                    this.currentPlayer2.destroy();
                    this.currentPlayer2 = null;
                }

                // Reset layout
                this.videoContainer.classList.remove('side-by-side');

                this.currentChannelId = null;
                this.currentChannelIds = [];
                this.overlay.style.display = 'none';
                this.status.style.display = 'none';
                this.showQRCode();
            }
            
            updateOverlay(channelId) {
                this.overlay.textContent = `Live`;
            }
            
            showStatus(type, message) {
                this.status.className = `status ${type}`;
                this.status.innerHTML = type === 'loading' ? 
                    `<div class="spinner"></div><div>${message}</div>` : 
                    `<div>${message}</div>`;
                this.status.style.display = 'block';
            }
            
            hideStatus() {
                this.status.style.display = 'none';
            }
            
            initializeAudioControl() {
                // Start with video muted to allow autoplay
                this.videoElement.muted = true;
                
                this.unmuteBtn.addEventListener('click', () => {
                    this.enableAudio();
                });
                
                this.videoElement.addEventListener('canplay', () => {
                    if (!this.isAudioEnabled) {
                        this.showUnmutePrompt();
                    }
                });
                
                this.videoElement.addEventListener('playing', () => {
                    if (!this.isAudioEnabled) {
                        this.showUnmutePrompt();
                    }
                });
            }
            
            enableAudio() {
                this.videoElement.muted = false;
                this.isAudioEnabled = true;
                this.hideUnmutePrompt();
                
                if (this.videoElement.paused) {
                    this.videoElement.play().catch(error => {
                        console.error('Error playing video after unmute:', error);
                    });
                }
            }
            
            showUnmutePrompt() {
                this.unmutePrompt.style.display = 'flex';
            }
            
            hideUnmutePrompt() {
                this.unmutePrompt.style.display = 'none';
            }

            initializeQRCode() {
                const joinUrl = window.location.origin + '/join';
                const qrApiUrl = `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodeURIComponent(joinUrl)}`;

                this.qrImage.src = qrApiUrl;
                this.qrImage.onerror = () => {
                    const fallbackUrl = `https://chart.googleapis.com/chart?chs=300x300&cht=qr&chl=${encodeURIComponent(joinUrl)}`;
                    this.qrImage.src = fallbackUrl;
                    this.qrImage.onerror = () => {
                        console.error('Failed to generate QR code');
                        // Hide QR code if generation fails
                        this.qrCodeContainer.style.display = 'none';
                    };
                };

                // Show QR code initially
                this.showQRCode();
            }

            showQRCode() {
                this.qrCodeContainer.style.display = 'block';
            }

            hideQRCode() {
                this.qrCodeContainer.style.display = 'none';
            }

            cleanup() {
                if (this.currentPlayer) {
                    this.currentPlayer.destroy();
                }
                if (this.currentPlayer2) {
                    this.currentPlayer2.destroy();
                }
            }
        }
        
        // Initialize when page loads
        let browserSource;
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                browserSource = new OBSBrowserSource();
            });
        } else {
            browserSource = new OBSBrowserSource();
        }
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (browserSource) {
                browserSource.cleanup();
            }
        });
    </script>
</body>
</html>